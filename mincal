#!/usr/bin/env python
from curses import *
import datetime
import calendar
import csv
import os
import pathlib
import configparser


# Write configuration file if it does not exist
config_folder = str(pathlib.Path.home())+"/.config/mincal"
if not os.path.exists(config_folder):
    os.makedirs(config_folder)
config_file = config_folder + "/config.ini"
conf = configparser.ConfigParser()

default_hint =  "n: Next month · p: Previous month · a: Add event · d: Delete · e: Edit · i: calcurse import · q: Quit · ?: Help"

def create_config():
    '''Create config file if it does not exist yet'''
    conf["Parameters"] = {
            "folder_with_datafile":      str(config_folder),
            "birthdays_from_abook":      "Yes",
            "show_keybindings":          "Yes",
            "show_day_names":            "Yes",
            "minimal_today_indicator":   "Yes",
            "minimal_days_indicator":    "Yes",
            "minimal_weekend_indicator": "Yes",
            "cut_titles_by_cell_length": "No",
            "ask_confirmations":         "No",
            "use_unicode_icons":         "Yes",
            "start_week_day":            "1",
            "event_icon":                "•",
            "today_icon":                "•",
            "birthday_icon":             "★",
            "hidden_icon":               "...",
            }

    conf["Colors"] = {
            "color_today":         "2",
            "color_days":          "7",
            "color_day_names":     "4",
            "color_weekends":      "1",
            "color_weekend_names": "1",
            "color_hints":         "7",
            "color_prompts":       "7",
            "color_confirmations": "1",
            "color_birthdays":     "1",
            }

    conf["Dialogues"] = {"hint": default_hint}

    conf["Event icons"] = {
            "travel":      "✈",
            "plane":       "✈",
            "trip":        "✈",
            "voyage":      "✈",
            "flight":      "✈",
            "airport":     "✈",
            "vacation":    "⛱",
            "holyday":     "⛱",
            "day-off":     "⛱",
            "hair":        "✂",
            "barber":      "✂",
            "beauty":      "✂",
            "nails":       "✂",
            "game":        "♟",
            "match":       "♟",
            "play":        "♟",
            "interview":   "♟",
            "date":        "♥",
            "concert":     "♪",
            "gig":         "♪",
            "disco":       "♪",
            "music":       "♪",
            "rehersal":    "♪",
            "call":        "☎",
            "phone":       "☎",
            "deadline":    "⚑",
            "over":        "⚑",
            "finish":      "⚑",
            "end":         "⚑",
            "appointment": "✔",
            "task ":       "✔",
            "doctor":      "⛑",
            "dentist":     "⛑",
            "medical":     "⛑",
            "hospital":    "⛑",
            "party":       "☘",
            "museum":      "⛬",
            "meet":        "⛬",
            "talk":        "⛬",
            "conference":  "⛬",
            "hearing":     "⛬",
            "sport":       "⛷",
            "gym":         "⛷",
            "training":    "⛷",
            }
    with open(config_file, 'w') as f:
        conf.write(f)

# Load configuration file
if not os.path.exists(config_file):
    create_config()

try:
    conf.read(config_file)
    SHOW_KEYBINDINGS          = conf.getboolean("Parameters", "show_keybindings", fallback=True)
    SHOW_DAY_NAMES            = conf.getboolean("Parameters", "show_day_names", fallback=True)
    MINIMAL_TODAY_INDICATOR   = conf.getboolean("Parameters", "minimal_today_indicator", fallback=True)
    MINIMAL_DAYS_INDICATOR    = conf.getboolean("Parameters", "minimal_days_indicator", fallback=True)
    MINIMAL_WEEKEND_INDICATOR = conf.getboolean("Parameters", "minimal_weekend_indicator", fallback=True)
    ASK_CONFIRMATIONS         = conf.getboolean("Parameters", "ask_confirmations", fallback=True)
    DISPLAY_ICONS             = conf.getboolean("Parameters", "use_unicode_icons", fallback=True)
    CUT_TITLES                = conf.getboolean("Parameters", "cut_titles_by_cell_length", fallback=False)
    BIRTHDAYS_FROM_ABOOK      = conf.getboolean("Parameters", "birthdays_from_abook", fallback=True)
    TODAY_ICON                = conf.get("Parameters", "today_icon", fallback="•")
    EVENT_ICON                = conf.get("Parameters", "event_icon", fallback="•")
    BIRTHDAY_ICON             = conf.get("Parameters", "birthday_icon", fallback="★")
    HIDDEN_ICON               = conf.get("Parameters", "hidden_icon", fallback="...")

    COLOR_TODAY         = int(conf.get("Colors", "color_today", fallback=2))
    COLOR_DAYS          = int(conf.get("Colors", "color_days", fallback=7))
    COLOR_DAY_NAMES     = int(conf.get("Colors", "color_day_names", fallback=4))
    COLOR_WEEKENDS      = int(conf.get("Colors", "color_weekends", fallback=1))
    COLOR_WEEKEND_NAMES = int(conf.get("Colors", "color_weekend_names", fallback=1))
    COLOR_HINTS         = int(conf.get("Colors", "color_hints", fallback=7))
    COLOR_PROMPTS       = int(conf.get("Colors", "color_prompts", fallback=7))
    COLOR_BIRTHDAYS     = int(conf.get("Colors", "color_birthdays", fallback=1))
    COLOR_CONFIRMATIONS = int(conf.get("Colors", "color_confirmations", fallback=1))
    START_WEEK_DAY      = int(conf.get("Parameters", "start_week_day", fallback=1))

    HINT = conf.get("Dialogues", "hint", fallback=default_hint)

    try:
        ICONS = {word: icon for (word, icon) in conf.items("Event icons")}
    except:
        ICONS = {}

    data_folder = conf.get("Parameters", "folder_with_datafile", fallback=config_folder)
except:
    print("Error in the config.ini file. Try deleting the config file and run the program again.")
    exit()


DATAFILE = data_folder + "/events.csv"
if not os.path.exists(data_folder):
    os.makedirs(data_folder)


def import_events_from_calcurse():
    '''Importing events from calcurse apt file into our events file'''
    calcurse_file = str(pathlib.Path.home())+"/.local/share/calcurse/apts"
    events = load_events()
    with open(calcurse_file, "r") as f:
        lines = f.readlines()
    for index, line in enumerate(lines):
        month = line[0:2]
        day = line[3:5]
        year = line[6:10]
        if line[11] == "[":
            name = line[15:-1]
        elif line[11] == "@":
            name = line[41:-1]
        event_id = 1 if not events['id'] else max(events['id'])+1
        new_event = str(event_id+index)+","+year+","+month+","+day+","+'"'+name+'"'
        with open(DATAFILE, "a") as f:
            f.write(new_event+"\n")


def parse_birthdays_from_abook():
    '''Loading birthdays from abook contacts'''
    if BIRTHDAYS_FROM_ABOOK:
        abook_file = str(pathlib.Path.home())+"/.abook/addressbook"
        bd_names, bd_dates = [], []
        abook = configparser.ConfigParser()
        abook.read(abook_file)
        for each_contact in abook.sections():
            for (key, value) in abook.items(each_contact):
                if key == "birthday":
                    bd_names.append(abook[each_contact]["name"])
                    bd_month = int(abook[each_contact]["birthday"][-5:-3])
                    bd_day = int(abook[each_contact]["birthday"][-2:])
                    bd_dates.append(datetime.date(1, bd_month, bd_day))
    return bd_dates, bd_names



def calculate_recurring_events(year, month, day, fr):
    '''Calculate the date of recurring events so that they occur in the next month or year'''
    new_day = day
    new_month = month
    new_year = year
    skip_days = 0
    if fr in ["w","d"]:
        for i in range(50):
            if month + i > 12:
                year = year + 1
                month = month - 12
            if day > skip_days + calendar.monthrange(year, month + i)[1]:
                skip_days += calendar.monthrange(year, month + i)[1]
                skip_months = i+1
            else:
                skip_months = i
                break
        new_day = day - skip_days
        new_month = month + skip_months
        new_year = year
    if fr == "m":
        if month > 12:
            new_year = year + (month-1)//12
            new_month = month - 12*(new_year-year)
    return datetime.date(new_year, new_month, new_day)


def load_events():
    '''Read from user's events file or create it if it does not exist'''
    try:
        with open(DATAFILE) as f:
            pass
    except IOError:
        with open(DATAFILE, "w+") as f:
            pass

    with open(DATAFILE,"r") as f:
        apts = csv.reader(f, delimiter = ',')
        ids, dates, names, reps, freq = [], [], [], [], []
        try:
            for row in apts:
                repetitions = int(row[5])
                for r in range(repetitions):
                    try:
                        fr = row[6]
                        year  = int(row[1]) + r*(fr=='y')
                        month = int(row[2]) + r*(fr=='m')
                        day   = int(row[3]) + r*(fr=='d') + 7*r*(fr=='w')
                        event_date = calculate_recurring_events(year, month, day, fr)
                        ids.append(int(row[0]))
                        dates.append(event_date)
                        names.append(row[4])
                        reps.append(int(row[5]))
                        freq.append(row[6])
                    except:
                        pass
        except:
            pass
        events = {'id': ids, 'dates': dates, 'names': names, 'reps': reps, 'freq': freq}
    return events


def add_event(stdscr, month, year, recurring):
    '''Ask user to input new recurring event and add it the file'''
    y_max, x_max = stdscr.getmaxyx()

    add_prompt = "Enter the date: "+str(year)+"/"+str(month)+"/"
    event_date = user_input(stdscr, add_prompt, 2)

    # If user's date is the number and is in this month, ask the title:
    days_of_this_month = range(1, calendar.monthrange(year, month)[1]+1)
    if int(event_date) in days_of_this_month:
        title_prompt = "Enter the title: "
        name = user_input(stdscr, title_prompt, x_max-len(title_prompt)-2)

        if recurring:
            rep_prompt = "How many times repeat the event: "
            repetitions = user_input(stdscr, rep_prompt, 3)
            freq_prompt = "Repeat the event every (d)ay, (w)eek, (m)onth or (y)ear?"
            prompt = freq_prompt + " "*abs(x_max - len(freq_prompt) - 1)
            stdscr.addstr(y_max-2, 0, prompt[:x_max-1], color_pair(8))
            frequency = stdscr.getkey()
        else:
            repetitions = 1
            frequency = "n"

        events = load_events()
        event_id = 1 if not events['id'] else max(events['id'])+1
        new_event = (str(event_id)+","+str(year)+","+str(month)+","+
                event_date+","+'"'+name+'"'+","+str(repetitions)+","+str(frequency))
        if len(name) > 0 and int(repetitions) >= 0 and frequency in ["d","w","m","y","n"]:
            with open(DATAFILE, "a") as f:
                f.write(new_event+"\n")


def delete_event(stdscr, events_this_month):
    '''Delete chosen events'''
    y_max, x_max = stdscr.getmaxyx()
    prompt_string = "Number of event to delete: "
    try:
        num = user_input(stdscr, prompt_string, 4)
        if int(num) in range(1, len(events_this_month)+1):
            event_id = events_this_month[int(num)-1][0]
            event_name = events_this_month[int(num)-1][1]
            prompt_string = "Really delete "+event_name+"? (y/n)"
            confirmed = ask_confirmation(stdscr, prompt_string)

            if confirmed:
                original_file = DATAFILE
                dummy_file = DATAFILE + '.bak'
                line_deleted = False
                with open(original_file, 'r') as read_obj, open(dummy_file, 'w') as write_obj:
                    for line in read_obj:
                        if line.startswith(str(event_id)+',') == False:
                            write_obj.write(line)
                        else:
                            line_deleted = True
                if line_deleted:
                    os.remove(original_file)
                    os.rename(dummy_file, original_file)
                else:
                    os.remove(dummy_file)
    except:
        pass


def edit_event(stdscr, events_this_month, month, year):
    '''Edit chosen event via deleting it and creating a new one'''
    y_max, x_max = stdscr.getmaxyx()
    prompt_string = "Number of event to edit: "
    num = (user_input(stdscr, prompt_string, 4))
    event_chosen = False
    # If provided number is correct, then delete the event:
    try:
        if int(num) in range(1, len(events_this_month)+1):
            recurring = True
            event_id = events_this_month[int(num)-1][0]
            event_name = events_this_month[int(num)-1][1]
            prompt_string = "Really edit "+event_name+"? (y/n)"
            confirmed = ask_confirmation(stdscr, prompt_string)
            if confirmed:
                original_file = DATAFILE
                dummy_file = DATAFILE + '.bak'
                line_deleted = False
                with open(original_file, 'r') as read_obj, open(dummy_file, 'w') as write_obj:
                    for line in read_obj:
                        if line.startswith(str(event_id)+',') == False:
                            write_obj.write(line)
                        else:
                            line_deleted = True
                if line_deleted:
                    os.remove(original_file)
                    os.rename(dummy_file, original_file)
                else:
                    os.remove(dummy_file)
                event_chosen = True
    except:
        pass

    if event_chosen:
        # First, ask the date within this month:
        add_prompt = "Enter new date: "+str(year)+"/"+str(month)+"/"
        event_date = user_input(stdscr, add_prompt, 2)

        # If user's date is the number and is in this month, ask the title:
        try:
            days_this_month = range(1, calendar.monthrange(year, month)[1]+1)
            if int(event_date) in days_this_month:
                title_prompt = "Enter new title: "
                name = user_input(stdscr, title_prompt, x_max-len(title_prompt)-2)

                rep_prompt = "How many times repeat the event: "
                repetitions = user_input(stdscr, rep_prompt, 3)
                freq_prompt = "Repeat the event every (d)ay, (w)eek, (m)onth or (y)ear?"
                prompt = freq_prompt + " "*abs(x_max - len(freq_prompt) - 1)
                stdscr.addstr(y_max-2, 0, prompt[:x_max-1], color_pair(8))
                frequency = stdscr.getkey()

                events = load_events()
                event_id = 1 if not events['id'] else max(events['id'])+1
                new_event = (str(event_id)+","+str(year)+","+str(month)+","+
                        event_date+","+'"'+name+'"'+","+str(repetitions)+","+str(frequency))
                if len(name) > 0 and int(repetitions) >= 0 and frequency in ["d","w","m","y","n"]:
                    with open(DATAFILE, "a") as f:
                        f.write(new_event+"\n")
        except:
            pass


def next_month(month, year):
    '''Switches to the next month'''
    if month < 12:
        month += 1
    else:
        month = 1
        year += 1
    return month, year


def previous_month(month, year):
    '''Switches to the previous month'''
    if month > 1:
        month -= 1
    else:
        month = 12
        year -= 1
    return month, year


def user_input(stdscr, prompt_string, answer_length):
    '''Ask user to input something and return this string'''
    y_max, x_max = stdscr.getmaxyx()
    echo()
    curs_set(True)
    display_string = str(prompt_string) + " "*abs((x_max-len(prompt_string))-1)
    stdscr.addstr(y_max - 2, 0, display_string[:x_max-1], color_pair(8))
    stdscr.refresh()
    user_input = stdscr.getstr(y_max - 2, len(prompt_string), answer_length).decode(encoding="utf-8")
    noecho()
    curs_set(False)
    return user_input


def display_day_names(stdscr, x_max):
    '''Display day name depending on the screen available'''
    if SHOW_DAY_NAMES:
        num = 2 if x_max < 80 else 10
        x_cell = int(x_max//7)
        for i in range(7):
            shift = START_WEEK_DAY-1
            day_number = i+shift - 7*((i+shift) > 6)
            name = calendar.day_name[day_number][:num].upper()
            color = 1 if day_number < 5 else 7
            stdscr.addstr(1, i*x_cell, name, color_pair(color))


def display_icon_for_event(name, delete_mode, edit_mode):
    '''Check if event seems of certain type and return corresponding icon'''
    if not delete_mode and not edit_mode and DISPLAY_ICONS:
        icon = EVENT_ICON + " "
        for key in ICONS:
            if key in name.lower():
                icon = ICONS[key] + " "
    else:
        icon = ""
    return icon


def ask_confirmation(stdscr, prompt_string):
    '''Ask user confirmation for an action'''
    y_max, x_max = stdscr.getmaxyx()
    if ASK_CONFIRMATIONS:
        halfdelay(255)
        prompt = prompt_string + " "*abs(x_max - len(prompt_string) - 1)
        stdscr.addstr(y_max-2, 0, prompt[:x_max-1], color_pair(9))
        key = stdscr.getkey()
        confirmed = True if key == "y" else False
    else:
        confirmed = True
    return confirmed


def initialize_colors(stdscr):
    '''Define all the color pairs'''
    start_color()
    use_default_colors()
    init_pair(1, COLOR_DAY_NAMES, -1)
    init_pair(6, COLOR_WEEKEND_NAMES, -1)
    init_pair(3, COLOR_HINTS, -1)
    init_pair(7, COLOR_BIRTHDAYS, -1)
    init_pair(8, COLOR_PROMPTS, -1)
    init_pair(9, COLOR_CONFIRMATIONS, -1)
    if MINIMAL_WEEKEND_INDICATOR:
        init_pair(2, COLOR_WEEKENDS, -1)
    else:
        init_pair(2, COLOR_BLACK, COLOR_WEEKENDS)
    if MINIMAL_TODAY_INDICATOR:
        init_pair(4, COLOR_TODAY, -1)
    else:
        init_pair(4, COLOR_BLACK, COLOR_TODAY)
    if MINIMAL_DAYS_INDICATOR:
        init_pair(5, COLOR_DAYS, -1)
    else:
        init_pair(5, COLOR_BLACK, COLOR_DAYS)


def main(stdscr):
    '''This is the main function that runs the screen'''
    my_cal = calendar.Calendar(firstweekday=START_WEEK_DAY-1)
    month  = datetime.date.today().month
    year   = datetime.date.today().year

    bd_dates, bd_names = parse_birthdays_from_abook()

    # Starting the screen
    stdscr = initscr()
    initialize_colors(stdscr)
    y_max, x_max = stdscr.getmaxyx()
    running      = True
    delete_mode  = False
    edit_mode    = False
    refresh_mode = False
    show_hints   = SHOW_KEYBINDINGS
    while running:
        stdscr.clear()
        halfdelay(255)
        noecho()
        curs_set(False)
        y_cell = (y_max-2)//6
        x_cell = x_max//7
        events = load_events()
        today = datetime.date.today()

        # Displaying the month, year, and days of the week
        month_string = calendar.month_name[month].upper()
        stdscr.addstr(0, 0, str(month_string)+" "+str(year))
        display_day_names(stdscr, x_max)

        # Displaying the dates and events
        day_number = 0
        num_of_event_this_month = 1
        events_this_month = []
        dates = my_cal.monthdayscalendar(year, month)
        for w in range(len(dates)):
            for d in range(7):
                day = dates[w][d]
                if day > 0:

                    # Display the dates
                    if datetime.date(year, month, day) == today:
                        color = 4
                        icon = TODAY_ICON if DISPLAY_ICONS else "·"
                    else:
                        shift = START_WEEK_DAY-1
                        day_number = d+shift - 7*((d+shift) > 6)
                        color = 5 if day_number < 5 else 2
                        icon = ""
                    date_display = str(day)+icon+str(" "*(x_cell-len(str(day))-len(icon)))
                    stdscr.addstr(2+w*y_cell, d*x_cell, date_display, color_pair(color))


                    # Display events
                    num_of_event_this_day = 0
                    for event_id, event_date, event_name in zip(events['id'], events['dates'], events['names']):
                        if datetime.date(year, month, day) == event_date:
                            if num_of_event_this_day < y_cell - 1: # If screen space is ok
                                icon = display_icon_for_event(event_name, delete_mode, edit_mode)
                                number = (str(len(events_this_month)+1)+"·")*(delete_mode or edit_mode)
                                disp = icon + number + event_name*(x_cell > 5)
                                disp = disp[:x_cell] if CUT_TITLES else disp[:x_max-d*x_cell]
                                stdscr.addstr(3+num_of_event_this_day+w*y_cell, d*x_cell, disp, color_pair(1))

                                num_of_event_this_day += 1
                                events_this_month.append([event_id, event_name])
                            else:
                                hidden = HIDDEN_ICON + " "*(x_cell - 3)
                                stdscr.addstr(3+num_of_event_this_day+w*y_cell-1, d*x_cell, hidden, color_pair(1))


                    # Display birthdays
                    if BIRTHDAYS_FROM_ABOOK:
                        for index, bd_date in enumerate(bd_dates):
                            try:
                                if bd_date == datetime.date(1, month, day):
                                    disp = BIRTHDAY_ICON*DISPLAY_ICONS+" "+bd_names[index]*(x_cell > 5)
                                    disp = disp[:x_cell] if CUT_TITLES else disp[:x_max-d*x_cell]
                                    stdscr.addstr(3+num_of_event_this_day+w*y_cell, d*x_cell, disp, color_pair(7))
                                    num_of_event_this_day += 1
                            except ValueError:
                                pass
                day_number += 1

        # Show hints in footer
        if show_hints:
            stdscr.addstr(y_max - 1, 0, HINT[:x_max-2], color_pair(3))

        # Handle user input
        refresh_mode = False
        if delete_mode:
            delete_event(stdscr, events_this_month)
            delete_mode = False
            refresh_mode = True

        if edit_mode:
            edit_event(stdscr, events_this_month, month, year)
            edit_mode = False
            refresh_mode = True

        if not refresh_mode:
            try:
                key = stdscr.getkey()

                # Handle "gg" to go to current month
                if key == "g":
                    try:
                        key = stdscr.getkey()
                        if key == "g":
                            month = today.month
                            year  = today.year
                        sdtscr.refresh()
                    except KeyboardInterrupt:
                        running = False
                    except:
                        pass

                # Handle screen resize
                if key == "KEY_RESIZE":
                    y_max, x_max = stdscr.getmaxyx()
                    stdscr.clear()
                    stdscr.refresh()

                # Handle rest of the user input
                if key in ["n", "j", "l", "KEY_UP", "KEY_RIGHT"]:
                    month, year = next_month(month, year)
                if key in ["p", "h", "k", "KEY_DOWN", "KEY_LEFT"]:
                    month, year = previous_month(month, year)
                if key in ["a", " "]:
                    recurring = False
                    add_event(stdscr, month, year, recurring)
                if key in ["A"]:
                    recurring = True
                    add_event(stdscr, month, year, recurring)
                if key in ["d", "x"]: delete_mode = True
                if key in ["e", "c"]: edit_mode = True
                if key == "q":
                    prompt_string = "Really exit? (y/n)"
                    confirmed = ask_confirmation(stdscr, prompt_string)
                    running = False if confirmed else True
                if key == "?": show_hints = not show_hints
                if key == "i": import_events_from_calcurse()
                if key in ["KEY_HOME", "G"]:
                    month = today.month
                    year  = today.year

            except KeyboardInterrupt:
                prompt_string = "Really exit? (y/n)"
                confirmed = ask_confirmation(stdscr, prompt_string)
                running = False if confirmed else True
            except:
                pass

    echo()
    curs_set(True)
    endwin()
    return

if __name__ == "__main__":
    wrapper(main)
