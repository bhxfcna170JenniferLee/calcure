#!/usr/bin/env python
from curses import *
import datetime
import calendar
import csv
import os
import pathlib
import configparser
import subprocess
import re


# Write configuration file if it does not exist:
config_folder = str(pathlib.Path.home())+"/.config/calcure"
if not os.path.exists(config_folder):
    os.makedirs(config_folder)
config_file = config_folder + "/config.ini"
conf = configparser.ConfigParser()

calcurse_todo_file = str(pathlib.Path.home()) + "/.local/share/calcurse/todo"
calcurse_events_file = str(pathlib.Path.home()) + "/.local/share/calcurse/apts"
default_calendar_hint =  "Space: Tasks · n/p: Change month · a: Add event · ?: Keybindings"
default_todo_hint = "Space: Calendar · a: Add · v: Done · i: Important · ?: Keybindings"

def create_config():
    '''Create config file if it does not exist yet'''
    conf["Parameters"] = {
            "folder_with_datafiles":     str(config_folder),
            "calcurse_todo_file":        str(calcurse_todo_file),
            "calcurse_events_file":      str(calcurse_events_file),
            "default_view":              "calendar",
            "birthdays_from_abook":      "Yes",
            "show_keybindings":          "Yes",
            "privacy_mode":              "No",
            "show_weather":              "No",
            "show_day_names":            "Yes",
            "minimal_today_indicator":   "Yes",
            "minimal_days_indicator":    "Yes",
            "minimal_weekend_indicator": "Yes",
            "cut_titles_by_cell_length": "No",
            "ask_confirmations":         "No",
            "use_unicode_icons":         "Yes",
            "start_week_day":            "1",
            "event_icon":                "•",
            "privacy_icon":              "•",
            "today_icon":                "•",
            "birthday_icon":             "★",
            "hidden_icon":               "...",

            "done_icon": "✔",
            "todo_icon": "•",
            "important_icon": "‣",
            "show_header": "Yes",
            "header": "TASKS:",
            }

    conf["Colors"] = {
            "color_today":         "2",
            "color_days":          "7",
            "color_day_names":     "4",
            "color_weekends":      "1",
            "color_weekend_names": "1",
            "color_hints":         "7",
            "color_prompts":       "7",
            "color_confirmations": "1",
            "color_birthdays":     "1",
            "color_todo":          "7",
            "color_done":          "6",
            "color_title":         "4",
            "color_important":     "1",
            }

    conf["Dialogues"] = {
            "calendar_hint": default_calendar_hint,
            "todo_hint": default_todo_hint,
            }

    conf["Event icons"] = {
            "travel":      "✈",
            "plane":       "✈",
            "trip":        "✈",
            "voyage":      "✈",
            "flight":      "✈",
            "airport":     "✈",
            "vacation":    "⛱",
            "holyday":     "⛱",
            "day-off":     "⛱",
            "hair":        "✂",
            "barber":      "✂",
            "beauty":      "✂",
            "nails":       "✂",
            "game":        "♟",
            "match":       "♟",
            "play":        "♟",
            "interview":   "♟",
            "date":        "♥",
            "concert":     "♪",
            "gig":         "♪",
            "disco":       "♪",
            "music":       "♪",
            "rehersal":    "♪",
            "call":        "☎",
            "phone":       "☎",
            "deadline":    "⚑",
            "over":        "⚑",
            "finish":      "⚑",
            "end":         "⚑",
            "doctor":      "✚",
            "dentist":     "✚",
            "medical":     "✚",
            "hospital":    "✚",
            "party":       "☘",
            "bar":         "☘",
            "museum":      "⛬",
            "meet":        "⛬",
            "talk":        "⛬",
            "conference":  "⛬",
            "hearing":     "⛬",
            "sport":       "⛷",
            "gym":         "⛷",
            "training":    "⛷",
            }
    with open(config_file, 'w') as f:
        conf.write(f)

# Load configuration file or create if it does not exist:
if not os.path.exists(config_file):
    create_config()

try:
    # Calendar settings:
    conf.read(config_file)
    SHOW_KEYBINDINGS          = conf.getboolean("Parameters", "show_keybindings", fallback=True)
    SHOW_DAY_NAMES            = conf.getboolean("Parameters", "show_day_names", fallback=True)
    MINIMAL_TODAY_INDICATOR   = conf.getboolean("Parameters", "minimal_today_indicator", fallback=True)
    MINIMAL_DAYS_INDICATOR    = conf.getboolean("Parameters", "minimal_days_indicator", fallback=True)
    MINIMAL_WEEKEND_INDICATOR = conf.getboolean("Parameters", "minimal_weekend_indicator", fallback=True)
    ASK_CONFIRMATIONS         = conf.getboolean("Parameters", "ask_confirmations", fallback=True)
    SHOW_WEATHER              = conf.getboolean("Parameters", "show_weather", fallback=False)
    DISPLAY_ICONS             = conf.getboolean("Parameters", "use_unicode_icons", fallback=True)
    PRIVACY_MODE              = conf.getboolean("Parameters", "privacy_mode", fallback=False)
    CUT_TITLES                = conf.getboolean("Parameters", "cut_titles_by_cell_length", fallback=False)
    BIRTHDAYS_FROM_ABOOK      = conf.getboolean("Parameters", "birthdays_from_abook", fallback=True)

    DEFAULT_VIEW  = conf.get("Parameters", "default_view", fallback="calendar")
    TODAY_ICON    = conf.get("Parameters", "today_icon", fallback="•") if DISPLAY_ICONS else "·"
    PRIVACY_ICON  = conf.get("Parameters", "privacy_icon", fallback="•") if DISPLAY_ICONS else "·"
    HIDDEN_ICON   = conf.get("Parameters", "hidden_icon", fallback="...")
    EVENT_ICON    = conf.get("Parameters", "event_icon", fallback="•")
    BIRTHDAY_ICON = conf.get("Parameters", "birthday_icon", fallback="★")

    # Todo settings:
    CALCURSE_TODO_FILE   = conf.get("Parameters", "calcurse_todo_file", fallback=calcurse_todo_file)
    CALCURSE_EVENTS_FILE = conf.get("Parameters", "calcurse_events_file", fallback=calcurse_events_file)
    TITLE                = conf.get("Parameters", "header", fallback="TASKS:")
    SHOW_TITLE           = conf.getboolean("Parameters", "show_header", fallback=True)
    SHOW_KEYBINDINGS     = conf.getboolean("Parameters", "show_keybindings", fallback=True)
    DONE_ICON            = conf.get("Parameters", "done_icon", fallback="✔") if DISPLAY_ICONS else "×"
    TODO_ICON            = conf.get("Parameters", "todo_icon", fallback="•") if DISPLAY_ICONS else "·"
    IMPORTANT_ICON       = conf.get("Parameters", "important_icon", fallback="‣") if DISPLAY_ICONS else "!"

    # Calendar colors:
    COLOR_TODAY         = int(conf.get("Colors", "color_today", fallback=2))
    COLOR_DAYS          = int(conf.get("Colors", "color_days", fallback=7))
    COLOR_DAY_NAMES     = int(conf.get("Colors", "color_day_names", fallback=4))
    COLOR_WEEKENDS      = int(conf.get("Colors", "color_weekends", fallback=1))
    COLOR_WEEKEND_NAMES = int(conf.get("Colors", "color_weekend_names", fallback=1))
    COLOR_HINTS         = int(conf.get("Colors", "color_hints", fallback=7))
    COLOR_PROMPTS       = int(conf.get("Colors", "color_prompts", fallback=7))
    COLOR_BIRTHDAYS     = int(conf.get("Colors", "color_birthdays", fallback=1))
    COLOR_CONFIRMATIONS = int(conf.get("Colors", "color_confirmations", fallback=1))
    START_WEEK_DAY      = int(conf.get("Parameters", "start_week_day", fallback=1))

    # Todo colors:
    COLOR_TODO      = int(conf.get("Colors", "color_todo", fallback=7))
    COLOR_DONE      = int(conf.get("Colors", "color_done", fallback=6))
    COLOR_TITLE     = int(conf.get("Colors", "color_title", fallback=1))
    COLOR_IMPORTANT = int(conf.get("Colors", "color_important", fallback=1))

    CALENDAR_HINT = conf.get("Dialogues", "calendar_hint", fallback=default_calendar_hint)
    TODO_HINT = conf.get("Dialogues", "todo_hint", fallback=default_todo_hint)

    try:
        ICONS = {word: icon for (word, icon) in conf.items("Event icons")}
    except:
        ICONS = {}

    data_folder = conf.get("Parameters", "folder_with_datafiles", fallback=config_folder)
except:
    print("Error in the config.ini file. Try deleting the config file and run the program again.")
    exit()

EVENTS_FILE = data_folder + "/events.csv"
TASKS_FILE = data_folder + "/tasks.csv"
if not os.path.exists(data_folder):
    os.makedirs(data_folder)


def import_events_from_calcurse():
    '''Importing events from calcurse apt file into our events file'''
    events = load_events()
    with open(CALCURSE_EVENTS_FILE, "r") as f:
        lines = f.readlines()
    for index, line in enumerate(lines):
        month = line[0:2]
        day = line[3:5]
        year = line[6:10]
        if line[11] == "[":
            name = line[15:-1]
        elif line[11] == "@":
            name = line[35:-1]
            name = name.replace('|',' ')
        event_id = 1 if not events['id'] else max(events['id'])+1
        new_event = str(event_id+index)+","+year+","+month+","+day+","+'"'+name+'"'+',1,n'
        with open(EVENTS_FILE, "a") as f:
            f.write(new_event+"\n")


def parse_birthdays_from_abook():
    '''Loading birthdays from abook contacts'''
    if BIRTHDAYS_FROM_ABOOK:
        abook_file = str(pathlib.Path.home())+"/.abook/addressbook"
        bd_names, bd_dates = [], []
        abook = configparser.ConfigParser()
        abook.read(abook_file)
        for each_contact in abook.sections():
            for (key, value) in abook.items(each_contact):
                if key == "birthday":
                    bd_names.append(abook[each_contact]["name"])
                    bd_month = int(abook[each_contact]["birthday"][-5:-3])
                    bd_day = int(abook[each_contact]["birthday"][-2:])
                    bd_dates.append(datetime.date(1, bd_month, bd_day))
    return bd_dates, bd_names


def calculate_recurring_events(year, month, day, fr):
    '''Calculate the date of recurring events so that they occur in the next month or year'''
    new_day   = day
    new_month = month
    new_year  = year
    skip_days = 0
    if fr in ["w","d"]:
        for i in range(1000):
            if month + i > 12:
                year = year + 1
                month = month - 12
            if day > skip_days + calendar.monthrange(year, month + i)[1]:
                skip_days += calendar.monthrange(year, month + i)[1]
                skip_months = i + 1
            else:
                skip_months = i
                break
        new_day = day - skip_days
        new_month = month + skip_months
        new_year = year
    if fr == "m":
        if month > 12:
            new_year = year + (month-1)//12
            new_month = month - 12*(new_year-year)
    return datetime.date(new_year, new_month, new_day)


def load_events():
    '''Read from user's events file or create it if it does not exist'''
    try:
        with open(EVENTS_FILE) as f:
            pass
    except IOError:
        with open(EVENTS_FILE, "w+") as f:
            pass

    with open(EVENTS_FILE,"r") as f:
        lines = csv.reader(f, delimiter = ',')
        ids, dates, names, reps, freq, statuses = [], [], [], [], [], []
        try:
            for line in lines:
                repetitions = int(line[5])
                for r in range(repetitions):
                    try:
                        fr = line[6]
                        year  = int(line[1]) + r*(fr=='y')
                        month = int(line[2]) + r*(fr=='m')
                        day   = int(line[3]) + r*(fr=='d') + 7*r*(fr=='w')
                        event_date = calculate_recurring_events(year, month, day, fr)
                        ids.append(int(line[0]))
                        dates.append(event_date)
                        names.append(line[4])
                        reps.append(int(line[5]))
                        freq.append(line[6])
                        # Update of the old format to accomodate statuses:
                        if len(line) < 8:
                            statuses.append("normal")
                        else:
                            statuses.append(line[7])
                    except:
                        pass
        except:
            pass
        events = {'id': ids, 'dates': dates, 'names': names, 'reps': reps, 'freq': freq, 'statuses': statuses}
    return events


def add_event(stdscr, month, year, recurring):
    '''Ask user to input new recurring event and add it the file'''
    y_max, x_max = stdscr.getmaxyx()

    add_prompt = "Enter the date: "+str(year)+"/"+str(month)+"/"
    event_date = user_input(stdscr, add_prompt, 2)

    # If user's date is the number and is in this month, ask the title:
    days_of_this_month = range(1, calendar.monthrange(year, month)[1]+1)
    if int(event_date) in days_of_this_month:
        title_prompt = "Enter the title: "
        name = user_input(stdscr, title_prompt, x_max-len(title_prompt)-2)

        if recurring:
            rep_prompt = "How many times repeat the event: "
            repetitions = user_input(stdscr, rep_prompt, 3)
            freq_prompt = "Repeat the event every (d)ay, (w)eek, (m)onth or (y)ear?"
            prompt = freq_prompt + " "*abs(x_max - len(freq_prompt) - 1)
            stdscr.addstr(y_max-2, 0, prompt[:x_max-1], color_pair(8))
            frequency = stdscr.getkey()
        else:
            repetitions = 1
            frequency = "n"

        events = load_events()
        event_id = 1 if not events['id'] else max(events['id'])+1
        new_event = (str(event_id)+","+str(year)+","+str(month)+","+
                event_date+","+'"'+name+'"'+","+str(repetitions)+","+
                str(frequency))
        if len(name) > 0 and int(repetitions) >= 0 and frequency in ["d","w","m","y","n"]:
            with open(EVENTS_FILE, "a") as f:
                f.write(new_event+"\n")


def delete_event(stdscr, ids_this_month, names_this_month):
    '''Delete chosen events'''
    y_max, x_max = stdscr.getmaxyx()
    prompt_string = "Number of event to delete: "
    try:
        num = user_input(stdscr, prompt_string, 4)
        if int(num) in range(1, len(ids_this_month)+1):

            event_id = ids_this_month[int(num)-1]
            event_name = names_this_month[int(num)-1]
            prompt_string = "Really delete "+event_name+"? (y/n)"
            confirmed = ask_confirmation(stdscr, prompt_string)

            if confirmed:
                original_file = EVENTS_FILE
                dummy_file = EVENTS_FILE + '.bak'
                line_deleted = False
                with open(original_file, 'r') as read_obj, open(dummy_file, 'w') as write_obj:
                    for line in read_obj:
                        if line.startswith(str(event_id)+',') == False:
                            write_obj.write(line)
                        else:
                            line_deleted = True
                if line_deleted:
                    os.remove(original_file)
                    os.rename(dummy_file, original_file)
                else:
                    os.remove(dummy_file)
    except:
        pass


def mark_event_as_important(stdscr, ids_this_month, names_this_month, month, year):
    '''Mark existing event as important'''
    y_max, x_max = stdscr.getmaxyx()
    prompt_string = "Mark as important event number: "
    num = (user_input(stdscr, prompt_string, 4))
    event_chosen = False
    # If provided number is correct, then change the status:
    try:
        if int(num) in range(1, len(ids_this_month)+1):
            recurring = True
            event_id = ids_this_month[int(num)-1]
            event_name = names_this_month[int(num)-1]

            # Here we work with a dummy file and replace the original in the last moment:
            original_file = EVENTS_FILE
            dummy_file = EVENTS_FILE + '.bak'
            line_deleted = False
            with open(original_file, 'r') as read_obj, open(dummy_file, 'w') as write_obj:
                for line in read_obj:
                    if not line.startswith(str(event_id)+','):
                        write_obj.write(line)
                    else:
                        if "important" in line[-11:]:
                            # line = line[:-10] + "\n"
                            line = re.sub(',important', '', line)
                        else:
                            # line = re.sub("", '', line)
                            line = line[:-1] + ',important\n'
                        write_obj.write(line)
                        line_edited = True
            if line_edited:
                os.remove(original_file)
                os.rename(dummy_file, original_file)
            else:
                os.remove(dummy_file)
    except:
        pass


def edit_event(stdscr, ids_this_month, names_this_month, month, year):
    '''Edit chosen event via deleting it and creating a new one'''
    y_max, x_max = stdscr.getmaxyx()
    prompt_string = "Number of event to edit: "
    num = (user_input(stdscr, prompt_string, 4))
    event_chosen = False
    # If provided number is correct, then delete the event:
    try:
        if int(num) in range(1, len(ids_this_month)+1):
            recurring = True
            event_id = ids_this_month[int(num)-1]
            event_name = names_this_month[int(num)-1]
            prompt_string = "Really edit "+event_name+"? (y/n)"
            confirmed = ask_confirmation(stdscr, prompt_string)
            if confirmed:
                original_file = EVENTS_FILE
                dummy_file = EVENTS_FILE + '.bak'
                line_deleted = False
                with open(original_file, 'r') as read_obj, open(dummy_file, 'w') as write_obj:
                    for line in read_obj:
                        if not line.startswith(str(event_id)+','):
                            write_obj.write(line)
                        else:
                            line_deleted = True
                if line_deleted:
                    os.remove(original_file)
                    os.rename(dummy_file, original_file)
                else:
                    os.remove(dummy_file)
                event_chosen = True
    except:
        pass

    if event_chosen:
        # First, ask the date within this month:
        add_prompt = "Enter new date: "+str(year)+"/"+str(month)+"/"
        event_date = user_input(stdscr, add_prompt, 2)

        # If user's date is the number and is in this month, ask the title:
        try:
            days_this_month = range(1, calendar.monthrange(year, month)[1]+1)
            if int(event_date) in days_this_month:
                title_prompt = "Enter new title: "
                name = user_input(stdscr, title_prompt, x_max-len(title_prompt)-2)

                rep_prompt = "How many times repeat the event: "
                repetitions = user_input(stdscr, rep_prompt, 3)
                freq_prompt = "Repeat the event every (d)ay, (w)eek, (m)onth or (y)ear?"
                prompt = freq_prompt + " "*abs(x_max - len(freq_prompt) - 1)
                stdscr.addstr(y_max-2, 0, prompt[:x_max-1], color_pair(8))
                frequency = stdscr.getkey()

                events = load_events()
                event_id = 1 if not events['id'] else max(events['id'])+1
                new_event = (str(event_id)+","+str(year)+","+str(month)+","+
                        event_date+","+'"'+name+'"'+","+str(repetitions)+","+str(frequency))
                if len(name) > 0 and int(repetitions) >= 0 and frequency in ["d","w","m","y","n"]:
                    with open(EVENTS_FILE, "a") as f:
                        f.write(new_event+"\n")
        except:
            pass


def next_month(month, year):
    '''Switches to the next month'''
    if month < 12:
        month += 1
    else:
        month = 1
        year += 1
    return month, year


def previous_month(month, year):
    '''Switches to the previous month'''
    if month > 1:
        month -= 1
    else:
        month = 12
        year -= 1
    return month, year


def user_input(stdscr, prompt_string, answer_length):
    '''Ask user to input something and return this string'''
    y_max, x_max = stdscr.getmaxyx()
    echo()
    curs_set(True)
    display_string = str(prompt_string) + " "*abs((x_max-len(prompt_string))-1)
    stdscr.addstr(y_max - 2, 0, display_string[:x_max-1], color_pair(8))
    stdscr.refresh()
    user_input = stdscr.getstr(y_max - 2, len(prompt_string), answer_length).decode(encoding="utf-8")
    noecho()
    curs_set(False)
    return user_input


def display_day_names(stdscr, x_max):
    '''Display day name depending on the screen available'''
    if SHOW_DAY_NAMES:
        num = 2 if x_max < 80 else 10
        x_cell = int(x_max//7)
        for i in range(7):
            shift = START_WEEK_DAY-1
            day_number = i+shift - 7*((i+shift) > 6)
            name = calendar.day_name[day_number][:num].upper()
            color = 1 if day_number < 5 else 6
            try:
                stdscr.addstr(1, i*x_cell, name, color_pair(color))
            except:
                pass


def display_icon(name, selection_mode=False):
    '''Check if event name contains a keyword and return corresponding icon'''
    if not selection_mode and DISPLAY_ICONS:
        icon = EVENT_ICON + " "
        for keyword in ICONS:
            if keyword in name.lower():
                icon = ICONS[keyword] + " "
    else:
        icon = ""
    return icon


def ask_confirmation(stdscr, prompt_string):
    '''Ask user confirmation for an action'''
    y_max, x_max = stdscr.getmaxyx()
    confirmed = True
    if ASK_CONFIRMATIONS:
        halfdelay(255)
        prompt = prompt_string + " "*abs(x_max - len(prompt_string) - 1)
        stdscr.addstr(y_max-2, 0, prompt[:x_max-1], color_pair(9))
        key = stdscr.getkey()
        confirmed = True if key == "y" else False
    return confirmed


def initialize_colors(stdscr):
    '''Define all the color pairs'''
    start_color()
    use_default_colors()
    init_pair(1, COLOR_DAY_NAMES, -1)
    init_pair(6, COLOR_WEEKEND_NAMES, -1)
    init_pair(3, COLOR_HINTS, -1)
    init_pair(7, COLOR_BIRTHDAYS, -1)
    init_pair(8, COLOR_PROMPTS, -1)
    init_pair(9, COLOR_CONFIRMATIONS, -1)
    if MINIMAL_WEEKEND_INDICATOR:
        init_pair(2, COLOR_WEEKENDS, -1)
    else:
        init_pair(2, COLOR_BLACK, COLOR_WEEKENDS)
    if MINIMAL_TODAY_INDICATOR:
        init_pair(4, COLOR_TODAY, -1)
    else:
        init_pair(4, COLOR_BLACK, COLOR_TODAY)
    if MINIMAL_DAYS_INDICATOR:
        init_pair(5, COLOR_DAYS, -1)
    else:
        init_pair(5, COLOR_BLACK, COLOR_DAYS)
    init_pair(10, COLOR_TITLE, -1)
    init_pair(11, COLOR_TODO, -1)
    init_pair(12, COLOR_DONE, -1)
    init_pair(13, COLOR_IMPORTANT, -1)


def check_weather(weather):
    '''Checking weather in the current location if it was not checked before'''
    if weather == "":
        try:
            weather = str(subprocess.getstatusoutput(f"curl -s wttr.in/?format=3")[1])
            weather = " " + weather.split(':')[1]
        except:
            pass
    return weather


def load_tasks():
    '''Reads from the user's appointments file'''
    try:
        with open(TASKS_FILE) as f:
            pass
    except IOError:
        with open(TASKS_FILE, "w+") as f:
            pass
    with open(TASKS_FILE,"r") as f:
        apts = csv.reader(f, delimiter = ',')
        tasks = []
        statuses = []
        try:
            for row in apts:
                tasks.append(row[0])
                statuses.append(row[1])
        except:
            pass
    return tasks, statuses


def add_task(stdscr):
    '''Promts the user to input new task and adds it to the file'''
    y_max, x_max = stdscr.getmaxyx()
    prompt_string = "New task: "
    new_task = user_input(stdscr, prompt_string, x_max - 1)
    if len(new_task) > 0:
        with open(TASKS_FILE,"a") as f:
            f.write(f'"{new_task}",todo\n')


def add_subtask(stdscr, tasks, statuses):
    '''Promts the user to input a subtask for existing taks and adds it to the file'''
    y_max, x_max = stdscr.getmaxyx()
    shift = 2 if SHOW_TITLE else 0
    for	i in range(len(tasks)):
        col = 1 if i+1 < 10 else 0
        stdscr.addstr(shift+i, col, str(i+1))
    prompt_string = "Add subtask for number: "
    number = user_input(stdscr, prompt_string, 4)
    if int(number) > 0 and int(number) <= len(tasks):
        prompt_string = "New subtask: "
        new_task = user_input(stdscr, prompt_string, x_max - 1)
        if len(new_task) > 0:
            tasks.insert(int(number), '--'+new_task)
            statuses.insert(int(number), statuses[int(number)-1])
            with open(TASKS_FILE,"w") as f:
                for task, status in zip(tasks, statuses):
                    f.write('"'+task+'",'+status+'\n')


def toggle_subtask(stdscr, tasks, statuses):
    '''Toggle between task and subtask state'''
    y_max, x_max = stdscr.getmaxyx()
    shift = 2 if SHOW_TITLE else 0
    for	i in range(len(tasks)):
        col = 1 if i+1 < 10 else 0
        stdscr.addstr(shift+i, col, str(i+1))
    prompt_string = "Which (sub)task to toggle: "
    number = user_input(stdscr, prompt_string, 4)
    if int(number) > 0 and int(number) <= len(tasks):
        if tasks[int(number)-1][:2] == '--':
            tasks[int(number)-1] = tasks[int(number)-1][2:]
        else:
            tasks[int(number)-1] = '--'+tasks[int(number)-1]
        with open(TASKS_FILE,"w") as f:
            for task, status in zip(tasks, statuses):
                f.write('"'+task+'",'+status+'\n')


def delete_all_tasks(stdscr):
    '''Delete all the tasks'''
    y_max, x_max = stdscr.getmaxyx()
    echo()
    curs_set(False)
    prompt_string = "Really delete all tasks? (y/n) "
    confirmed = ask_confirmation(stdscr, prompt_string)
    if confirmed:
        with open(TASKS_FILE, 'w'):
            pass


def calcurse_import(stdscr):
    '''Import todo events from calcurse database'''
    y_max, _ = stdscr.getmaxyx()
    prompt_string = "Import tasks from calcurse? (y/n) "
    confirmed = ask_confirmation(stdscr, prompt_string)
    if confirmed:
        with open(CALCURSE_TODO_FILE, 'r') as f:
            for task in f.readlines():
                if len(task) > 0:
                    with open(TASKS_FILE,"a") as f:
                        if task[1] in ['1','2']:
                            f.write('"'+task[4:-1]+'"' + ",important\n")
                        else:
                            f.write('"'+task[4:-1]+'"' + ",todo\n")


def mark_all_as_done(stdscr, tasks):
    '''Mark all the tasks as done'''
    y_max, x_max = stdscr.getmaxyx()
    echo()
    curs_set(False)
    prompt_string = "Really mark all tasks as done? (y/n) "
    confirmed = ask_confirmation(stdscr, prompt_string)
    if confirmed:
        with open(TASKS_FILE, "w") as f:
            for task in tasks:
                f.write(task + ",done\n")


def mark_all_as_important(stdscr, tasks):
    '''Mark all the tasks as important'''
    y_max, x_max = stdscr.getmaxyx()
    echo()
    curs_set(False)
    prompt_string = "Really mark all tasks as important? (y/n) "
    confirmed = ask_confirmation(stdscr, prompt_string)
    if confirmed:
        with open(TASKS_FILE, "w") as f:
            for task in tasks:
                f.write(task + ",important\n")


def unmark_all_tasks(stdscr, tasks):
    '''Unmark all the tasks'''
    y_max, x_max = stdscr.getmaxyx()
    echo()
    curs_set(False)
    prompt_string = "Really unmark all tasks? (y/n) "
    confirmed = ask_confirmation(stdscr, prompt_string)
    if confirmed:
        with open(TASKS_FILE, "w") as f:
            for task in tasks:
                f.write(task + ",todo\n")


def delete_task(stdscr, tasks, statuses):
    '''Promts the user which task to delete and changes the file'''
    y_max, x_max = stdscr.getmaxyx()
    shift = 2 if SHOW_TITLE else 0
    for	i in range(len(tasks)):
        col = 1 if i+1 < 10 else 0
        stdscr.addstr(shift+i, col, str(i+1))
    prompt_string = "Delete task number: "
    number = user_input(stdscr, prompt_string, 4)
    if int(number) > 0 and int(number) <= len(tasks):
        prompt_string = "Really delete this task? (y/n) "
        confirmed = ask_confirmation(stdscr, prompt_string)
        if confirmed:
            to_delete = [int(number)-1]
            # Mark subtasks to be deleted as well:
            if tasks[int(number)-1][:2] != '--':
                for i in range(int(number), len(tasks)):
                    if tasks[i][:2] == '--':
                        to_delete.append(i)
                    else:
                        break
            # Delete marked tasks:
            for index in reversed(to_delete):
                del tasks[index]
                del statuses[index]
            with open(TASKS_FILE,"w") as f:
                for task, status in zip(tasks, statuses):
                    f.write(task+","+status+"\n")


def edit_task(stdscr, tasks, statuses):
    '''Promt the user which task to delete and change the file'''
    y_max, x_max = stdscr.getmaxyx()
    shift = 2 if SHOW_TITLE else 0
    for	i in range(len(tasks)):
        col = 1 if i+1 < 10 else 0
        stdscr.addstr(shift+i, col, str(i+1))
    prompt_string = "Edit task number: "
    number = user_input(stdscr, prompt_string, 4)

    if int(number) > 0 and int(number) <= len(tasks):
        prompt_string = "New task: "
        new_task = user_input(stdscr, prompt_string, x_max - 1)
        if len(new_task) > 0:
            if tasks[int(number)-1][:2] == "--":
                new_task = "--"+new_task
            tasks[int(number)-1] = new_task
            with open(TASKS_FILE,"w") as f:
                for task, status in zip(tasks, statuses):
                    f.write('"'+task+'",'+status+'\n')


def mark_as_done(stdscr, tasks, statuses):
    '''Promts the user to witch task to mark as done and changes the file'''
    y_max, x_max = stdscr.getmaxyx()
    shift = 2 if SHOW_TITLE else 0
    for	i in range(len(tasks)):
        col = 1 if i+1 < 10 else 0
        stdscr.addstr(shift+i, col, str(i+1))
    prompt_string = "Mark as done task number: "
    number = user_input(stdscr, prompt_string, 4)
    if int(number) > 0 and int(number) <= len(tasks):
        statuses[int(number)-1] = "done"

        # if there are subtasks, mark them as well:
        if tasks[int(number)-1][:2] != '--':
            for i in range(int(number), len(tasks)):
                if tasks[i][:2] == '--':
                    statuses[i] = "done"
                else:
                    break
        with open(TASKS_FILE,"w") as f:
            for task, status in zip(tasks, statuses):
                f.write(task+","+status+"\n")


def mark_as_important(stdscr, tasks, statuses):
    '''Promts the user to witch task to mark as done and changes the file'''
    y_max, x_max = stdscr.getmaxyx()
    shift = 2 if SHOW_TITLE else 0
    for	i in range(len(tasks)):
        col = 1 if i+1 < 10 else 0
        stdscr.addstr(shift+i, col, str(i+1))
    prompt_string = "Mark as important task number: "
    number = user_input(stdscr, prompt_string, 4)
    if int(number) > 0 and int(number) <= len(tasks):
        statuses[int(number)-1] = "important"

        # if there are subtasks, mark them as well:
        if tasks[int(number)-1][:2] != '--':
            for i in range(int(number), len(tasks)):
                if tasks[i][:2] == '--':
                    statuses[i] = "important"
                else:
                    break
        with open(TASKS_FILE,"w") as f:
            for task, status in zip(tasks, statuses):
                f.write(task+","+status+"\n")


def unmark_task(stdscr, tasks, statuses):
    '''Promt the user which task to unmark as done and rewrites the file'''
    y_max, x_max = stdscr.getmaxyx()
    shift = 2 if SHOW_TITLE else 0
    for	i in range(len(tasks)):
        col = 1 if i+1 < 10 else 0
        stdscr.addstr(shift+i, col, str(i+1))
    prompt_string = "Unmark task number: "
    number = user_input(stdscr, prompt_string, 4)
    if int(number) > 0 and int(number) <= len(tasks):
        statuses[int(number)-1] = "todo"

        # if there are subtasks, unmark them as well:
        if tasks[int(number)-1][:2] != '--':
            for i in range(int(number), len(tasks)):
                if tasks[i][:2] == '--':
                    statuses[i] = "todo"
                else:
                    break
        with open(TASKS_FILE,"w") as f:
            for task, status in zip(tasks, statuses):
                f.write(task+","+status+"\n")


def monthly_screen(stdscr, my_cal, month, year, state, privacy_on, weather):
    '''This is the calendar view that shows events'''
    bd_dates, bd_names = parse_birthdays_from_abook()
    y_max, x_max   = stdscr.getmaxyx()
    selection_mode = False
    refresh_mode   = False
    running        = True
    show_hints     = SHOW_KEYBINDINGS


    while running:
        stdscr.clear()
        halfdelay(255)
        noecho()
        curs_set(False)
        y_cell = (y_max-2)//6
        x_cell = x_max//7
        events = load_events()
        today = datetime.date.today()

        # Displaying the month, year, and days of the week
        month_string = calendar.month_name[month].upper()
        stdscr.addstr(0, 0, str(month_string)+" "+str(year))
        display_day_names(stdscr, x_max)

        # Displaying the dates and events:
        day_number = 0
        ids_this_month = []
        names_this_month = []
        event_number = 0
        dates = my_cal.monthdayscalendar(year, month)
        for w in range(len(dates)):
            for d in range(7):
                day = dates[w][d]
                if day > 0:

                    # Display dates of the month:
                    if datetime.date(year, month, day) == today:
                        color = 4
                        icon = TODAY_ICON
                    else:
                        shift = START_WEEK_DAY-1
                        day_number = d+shift - 7*((d+shift) > 6)
                        color = 5 if day_number < 5 else 2
                        icon = ""
                    date_display = str(day) + icon + str(" "*(x_cell-len(str(day))-len(icon)))
                    try:
                        stdscr.addstr(2+w*y_cell, d*x_cell, date_display, color_pair(color))
                    except:
                        pass


                    # Display events:
                    num_of_event_this_day = 0
                    for event_id, event_date, event_name, event_status in zip(events['id'], events['dates'], events['names'], events['statuses']):

                        # Check if this event happens in this day and screen space is okay:
                        if datetime.date(year, month, day) == event_date:
                            if num_of_event_this_day < y_cell - 1:
                                icon = display_icon(event_name, selection_mode)

                                # Check if this is a recurring event:
                                if event_id in ids_this_month:
                                    event_number = ids_this_month.index(event_id) + 1
                                else:
                                    event_number += 1
                                    ids_this_month.append(event_id)
                                    names_this_month.append(event_name)

                                # Display the event:
                                number = (str(event_number)+"·")*(selection_mode)
                                if privacy_on: event_name = PRIVACY_ICON*len(event_name)
                                disp = icon + number + event_name*(x_cell > 5)
                                disp = disp[:x_cell] if CUT_TITLES else disp[:x_max-d*x_cell]
                                disp = disp + " "*abs(x_max - x_cell*d - len(disp))
                                color = 13 if event_status == 'important' else 1
                                try:
                                    stdscr.addstr(3+num_of_event_this_day+w*y_cell, d*x_cell, disp, color_pair(color))
                                except:
                                    pass

                                num_of_event_this_day += 1
                            else:
                                hidden = HIDDEN_ICON + " "*(x_cell - 3)
                                try:
                                    stdscr.addstr(3+num_of_event_this_day+w*y_cell-1, d*x_cell, hidden, color_pair(1))
                                except:
                                    pass



                    # Display birthdays:
                    if BIRTHDAYS_FROM_ABOOK:
                        for index, bd_date in enumerate(bd_dates):
                            try:
                                if bd_date == datetime.date(1, month, day):
                                    if privacy_on: event_name = PRIVACY_ICON*len(event_name)
                                    bd_name = PRIVACY_ICON*len(bd_names[index]) if privacy_on else bd_names[index]
                                    disp = (BIRTHDAY_ICON+" ")*DISPLAY_ICONS+bd_name*(x_cell > 5)
                                    disp = disp[:x_cell] if CUT_TITLES else disp[:x_max-d*x_cell]
                                    try:
                                        stdscr.addstr(3+num_of_event_this_day+w*y_cell, d*x_cell, disp, color_pair(7))
                                    except:
                                        pass
                                    num_of_event_this_day += 1
                            except ValueError:
                                pass
                day_number += 1

        # Display weather
        if SHOW_WEATHER:
            stdscr.refresh()
            weather = check_weather(weather)
            if len(weather) < x_max-len(month_string):
                stdscr.addstr(0, x_max-len(weather)-1, weather, color_pair(4))

        # Show keybinding hint:
        if show_hints:
            stdscr.addstr(y_max - 1, 0, CALENDAR_HINT[:x_max-2], color_pair(3))

        # Handle user input:

        # If we need to choose one of the events:
        refresh_mode = False
        if selection_mode:
            if key in ["d", "x"]:
                delete_event(stdscr, ids_this_month, names_this_month)
            elif key in ["e", "c"]:
                edit_event(stdscr, ids_this_month, names_this_month, month, year)
            elif key in ["i"]:
                mark_event_as_important(stdscr, ids_this_month, names_this_month, month, year)
            selection_mode = False
            refresh_mode = True

        # Otherwise, check for regular keys:
        if not refresh_mode:
            try:
                key = stdscr.getkey()

                # Handle "gg" to go to current month:
                if key == "g":
                    try:
                        key = stdscr.getkey()
                        if key == "g":
                            month = today.month
                            year  = today.year
                        sdtscr.refresh()
                    except KeyboardInterrupt:
                        running = False
                    except:
                        pass

                # Handle screen resize:
                if key == "KEY_RESIZE":
                    y_max, x_max = stdscr.getmaxyx()
                    stdscr.clear()
                    stdscr.refresh()

                # Handle rest of the keybindings:
                if key in ["n", "j", "l", "KEY_UP", "KEY_RIGHT"]:
                    month, year = next_month(month, year)
                if key in ["p", "h", "k", "KEY_DOWN", "KEY_LEFT"]:
                    month, year = previous_month(month, year)
                if key in ["a"]:
                    recurring = False
                    add_event(stdscr, month, year, recurring)
                if key in ["A"]:
                    recurring = True
                    add_event(stdscr, month, year, recurring)
                if key in ["d", "x"]: selection_mode = True
                if key in ["e", "c"]: selection_mode = True
                if key in ["i"]: selection_mode = True
                if key == "q":
                    prompt_string = "Really exit? (y/n)"
                    confirmed = ask_confirmation(stdscr, prompt_string)
                    if confirmed:
                        running = False
                        state = 'exit'
                if key == "?":
                    running = False
                    state = 'help_screen'
                if key == "*": privacy_on = not privacy_on
                if key == "C": import_events_from_calcurse()
                if key in ["KEY_HOME", "G"]:
                    month = today.month
                    year  = today.year
                if key in ["KEY_TAB", " "]:
                    running = False
                    state = 'task_screen'

            # Handle keybard interruption with ctr+c:
            except KeyboardInterrupt:
                prompt_string = "Really exit? (y/n)"
                confirmed = ask_confirmation(stdscr, prompt_string)
                if confirmed:
                    running = False
                    state = 'exit'

            # This except is necessary to prevent many various crashes:
            except:
                pass
    return state, privacy_on, month, year, weather


def task_screen(stdscr, state, privacy_on):
    '''This is the todo view that shows the screen with tasks'''
    y_max, x_max = stdscr.getmaxyx()
    running = True
    show_hints = SHOW_KEYBINDINGS
    while (running):
        stdscr.clear()
        noecho()
        halfdelay(255)
        curs_set(False)
        tasks, statuses = load_tasks()
        try:
            # Display the header:
            if SHOW_TITLE:
                stdscr.addstr(0, 0, TITLE[:x_max-3], color_pair(10))
            shift = 2 if SHOW_TITLE else 0

            # Display the tasks:
            for index, task in enumerate(tasks):
                task = task[:x_max-3]

                # Check the tabbing for subtasks:
                tab = 1
                if task[:2] == '--':
                    tab += 2
                    task = task[2:]

                if privacy_on: task = PRIVACY_ICON*len(task)
                if statuses[index] == "done":
                    stdscr.addstr(index+shift, tab,DONE_ICON, color_pair(12))
                    stdscr.addstr(index+shift, tab+2, task, color_pair(12))
                elif statuses[index] == "important":
                    stdscr.addstr(index+shift, tab,IMPORTANT_ICON, color_pair(13))
                    stdscr.addstr(index+shift, tab+2, task, color_pair(13))
                else:
                    icon = display_icon(task)
                    stdscr.addstr(index+shift, tab, icon, color_pair(11))
                    stdscr.addstr(index+shift, tab+2, task, color_pair(11))

            # Show keybinding:
            if show_hints:
                stdscr.addstr(y_max - 1, 0, TODO_HINT[:x_max-2], color_pair(3))
        except:
            pass

        stdscr.refresh()

        # Getting user's input:
        try:
            key = stdscr.getkey()

            # Handle screen resize:
            if key == "KEY_RESIZE":
                y_max, x_max = stdscr.getmaxyx()
                stdscr.clear()
                stdscr.refresh()

            # Handle various keys:
            if key == "a": add_task(stdscr)
            if key == "A": add_subtask(stdscr, tasks, statuses)
            if key == "D": delete_all_tasks(stdscr)
            if key == "v": mark_as_done(stdscr, tasks, statuses)
            if key == "V": mark_all_as_done(stdscr, tasks)
            if key == "i": mark_as_important(stdscr, tasks, statuses)
            if key == "I": mark_all_as_important(stdscr, tasks)
            if key == "u": unmark_task(stdscr, tasks, statuses)
            if key == "U": unmark_all_tasks(stdscr, tasks)
            if key == "s": toggle_subtask(stdscr, tasks, statuses)
            if key == "*": privacy_on = not privacy_on
            if key == "C": calcurse_import(stdscr)
            if key == "d": delete_task(stdscr, tasks, statuses)
            if key in ["e", "c"]: edit_task(stdscr, tasks, statuses)
            if key == " ":
                running = False
                state = 'monthly_screen'
            if key == "?":
                running = False
                state = 'help_screen'
            if key == "q":
                prompt_string = "Really exit? (y/n) "
                confirmed = ask_confirmation(stdscr, prompt_string)
                if confirmed:
                    running = False
                    state = 'exit'

        # Handle keybard interruption with ctr+c:
        except KeyboardInterrupt:
            prompt_string = "Really exit? (y/n) "
            confirmed = ask_confirmation(stdscr, prompt_string)
            if confirmed:
                running = False
                state = 'exit'

        # This except is necessary to prevent many various crashes:
        except:
            pass
    return state, privacy_on


def help_screen(stdscr, state):
    '''This is the help view that shows all the keybinding'''
    y_max, x_max = stdscr.getmaxyx()
    running = True
    while (running):
        stdscr.clear()
        noecho()
        curs_set(False)

        # Keybinding dictionaries:
        keys_general = {
                'space': 'Switch between calendar and tasks',
                '  ?  ': 'Toggle this help',
                '  *  ': 'Toggle privacy mode',
                '  q  ': 'Quit',
                }

        keys_calendar = {
                '  n  ': 'Next month',
                '  p  ': 'Previous month',
                '  a  ': 'Add an event',
                '  A  ': 'Add a recurring event',
                '  i  ': 'Mark/unmark an event as important',
                '  d  ': 'Delete an event',
                '  e  ': 'Edit an event',
                '  C  ': 'Import events from calcurse',
                '  G  ': 'Return to current month',
                }

        keys_todo = {
                '  a  ': 'Add a task',
                '  A  ': 'Add a subtask',
                '  i  ': 'Mark a task as important',
                '  I  ': 'Mark all as important',
                '  d  ': 'Delete a task (with all subtasks)',
                '  D  ': 'Delete all tasks',
                '  e  ': 'Edit a task',
                '  s  ': 'Toggle between task and subtask',
                '  C  ': 'Import tasks from calcurse',
                }

        # Printing out the dictionaries:
        try:
            stdscr.addstr(0, 0, "KEYBINDINGS"[:x_max-3], color_pair(6))
            stdscr.addstr(2, 6, "General"[:x_max-3], color_pair(4))
            for index, key in enumerate(keys_general):
                line = str(key+" "+keys_general[key])[:x_max-3]
                stdscr.addstr(index+3, 0, line, color_pair(5))

            stdscr.addstr(4+len(keys_general), 6, "Calendar view"[:x_max-3], color_pair(4))
            for index, key in enumerate(keys_calendar):
                line = str(key+" "+keys_calendar[key])[:x_max-3]
                stdscr.addstr(index+5+len(keys_general), 0, line, color_pair(5))

            stdscr.addstr(6+len(keys_calendar)+len(keys_general), 6, "Task view"[:x_max-3], color_pair(4))
            for index, key in enumerate(keys_todo):
                line = str(key+" "+keys_todo[key])[:x_max-3]
                stdscr.addstr(index+7+len(keys_general)+len(keys_calendar), 0, line, color_pair(5))
            stdscr.addstr(8+len(keys_todo)+len(keys_general)+len(keys_calendar), 0, "Vim keys work as well!", color_pair(1))
        except:
            pass

        stdscr.refresh()

        # Getting user's input:
        try:
            key = stdscr.getkey()

            # Handle screen resize:
            if key == "KEY_RESIZE":
                y_max, x_max = stdscr.getmaxyx()
                stdscr.clear()
                stdscr.refresh()

            # Handle keys to exit the help screen:
            if key in [" ", "?", "q"]:
                running = False
                state = 'monthly_screen'

        except KeyboardInterrupt:
            prompt_string = "Really exit? (y/n) "
            confirmed = ask_confirmation(stdscr, prompt_string)
            if confirmed:
                running = False
                state = 'exit'
        except:
            pass
    return state


def main(stdscr):
    '''This is the main function that runs the screen'''
    my_cal = calendar.Calendar(firstweekday=START_WEEK_DAY-1)
    month  = datetime.date.today().month
    year   = datetime.date.today().year
    privacy_on   = PRIVACY_MODE
    weather      = ''

    if DEFAULT_VIEW == 'calendar':
        state = 'monthly_screen'
    else:
        state = 'task_screen'

    # Starting the screen:
    stdscr = initscr()
    initialize_colors(stdscr)

    # Running various screens depending on the state:
    while state != 'exit':
        if state == 'monthly_screen':
            state, privacy_on, month, year, weather = monthly_screen(stdscr, my_cal, month, year, state, privacy_on, weather)
        elif state == 'task_screen':
            state, privacy_on = task_screen(stdscr, state, privacy_on)
        elif state == 'help_screen':
            state = help_screen(stdscr, state)
        else:
            break

    # Cleaning up:
    echo()
    curs_set(True)
    endwin()


if __name__ == "__main__":
    wrapper(main)
